---
group:
  title: AI 打铁铺
tags:
  - AI
  - BMAD
  - AI Coding
  - 工作流
sidebar: false
sticky: 1
date: 2025-10-31 00:00:00
recommend: 1
title: 前端 AI-Coding 工程化 | 基于 BMad 的开发工作流设计思路
description: 以 BMAD 4.4 方法为核心，结合企业内部已有的产品研发体系，实现从 PRD 到开发交付的完整闭环。采用"多角色 + 多会话 + 人工复核 + 上下文交接包"机制，减少 AI 幻觉、提升交付质量。
cover: ""
---


# 前端AI-Coding工程化 | 基于 BMad 的开发工作流设计思路

（版本：BMAD 4.4 Hybrid Workflow — 人机协作多会话模式）

## 一、总体概述
本工作流以 BMAD 4.4 方法为核心，结合企业内部已有的产品研发体系，实现了从 PRD 到开发交付的完整闭环。
 目标是在确保 AI 协作稳定性的同时，建立一套非专家用户亦可执行的可复制流程。

 工作流采用“多角色 + 多会话 + 人工复核 + 上下文交接包”机制，以减少 AI 幻觉、提升结果一致性与交付质量。

**基本名词：**
*   PM（产品经理）、PO（产品负责人）、SM（敏捷教练）、QA（测试工程师）、RD（开发工程师）
*   PRD（产品需求文档）、Epic （用户故事合集、史诗）、Stories （用户故事）、API（访问接口文档）

**优缺点速览**
对个人而言，这套流程稳定但繁琐，能保证结果一致却牺牲灵活与效率；
对团队而言，它标准化且可复制，能显著提升Vibe Coding场景的整体交付质量，但同时增加了培训成本与执行复杂度。

## 二、工作流图示

## 三、工作流循环
### 项目启动

1.  **获取产品需求文档**
    公司配备产品经理，我们可以直接从 PM（产品经理） 处获取完整的 PRD 文档。

2.  **初始化开发流程**
    将 PRD 导出后，在 IDE 中启动 BMAD 工作流，向元角色 Master 说明即将开发的功能模块。

    `@bmad-master.md 我准备开发一个查单词的功能，继承到学生端项目中，目前 prd 已经完成，[prd文件目录]`

### 需求分解

3.  **拆分 Epic（史诗故事）**
    执行者： PO（Product Owner，产品负责人）
    根据 PRD 中的功能模块划分，将需求拆解为多个 Epic。

    `@PO 查看 PRD 并根据功能模块划分拆分为多个 Epic`

4.  **拆分 User Stories（用户故事）**
    执行者： SM（Scrum Master，敏捷教练）
    基于 PRD 和已拆分的 Epic，继续细化为粒度更小的用户故事。

```
@SM 根据 PRD 内个和已经拆分的Epic，细化整理完整的用户故事
```

### AI 辅助质检 Epic 和 Stories

5.  **Epic & Stories AI 检查阶段**
    ⚠️ **重要：** 打开新的会话，控制上下文。不要让模型再一次会话中读到之前已经产生的 Epic 和 Stories，会有幻觉。直接新开会话给上一步生产的文档，这个是有区别的。

    **操作步骤：**
    *   将每个 Epic 对应的 PRD 原文直接复制粘贴进来
    *   召集 PM、PO、SM 三个角色同时检查 Epic 和 Stories
    *   AI 会按严重等级排序列出发现的问题（大概率会有细节问题）
    *   人工决策并给出修订意见：
        *   常规操作：让 AI 参考 PRD 原文进行修改
        *   特殊情况：发现信息缺失时，需要找 PM 核对确认
    *   AI 根据人工意见修订需求分解第 3、4 步产出的 Epic 和 Stories

    **为什么需要这一步？**
    *   问题一： AI 存在幻觉问题，第 3、4 步的产出不一定完全准确
    *   问题二： 大部分人没有足够耐心完整阅读所有 Epic 和 Stories

### 人工质量把关 Epic 和 Stories

6.  **Epic & Stories 人工检查阶段**

    **检查标准：**
    *   **Epic 检查：** 需要通读全文
        *   Epic 通常不会太长，主要是概括性内容
        *   确保方向和范围准确
    *   **Stories 检查：** 只需检查文件名
        *   无需细读每个 Story 的详细内容
        *   通过文件名判断覆盖范围是否完整
    *   **版本保护：**使用第 6 步的方法循环检查并修订完所有 Epic 和 Stories 后：
        *   立即提交到 Git
        *   目的： 防止后续 AI 在不知情的情况下修改内容

### 架构设计

7.  **系统架构设计**
    ⚠️ **重要：**都打开新的会话，控制上下文

    **准备工作：**
    *   导出 API 文档并放入项目的 docs 目录
    *   收集完整材料：PRD + Epic + Stories + API 文档

    **执行流程：**
    *   将上述所有材料提供给架构师角色
    *   架构师进行架构设计并输出架构文档

    对于产出的架构文档人工审核重点：
    *   ✅ 目录结构是否合理
    *   ✅ 架构模式是否适配
    *   ✅ 技术栈选型是否恰当

    💡 **省力建议：**
    *   不必全篇通读架构文档（心智负担太大）
    *   即使我们通读全篇并修改得非常准确，在实际实现过程中 AI 也不一定完全遵循
    *   这跟人工开发是一样的道理——众多因素影响下，不可能完全按照架构文档实现
    *   结论： 这个环节不必投入过多精力

### 🔄 开发测试循环

8.  **开发循环工作流**
    ⚠️ **重要：**不开新会话，给 Dev 完整的上下文

    架构文档完成后，交给 Dev 角色按用户故事的顺序依次开发，进入开发循环。

    **8.1 Epic 功能开发与基础验证**

    **开发节奏：**
    *   通常开发完一整个 Epic 后再进行人工检查

    **人工验证内容：**
    *   功能实现是否完整？
    *   是否存在明显 Bug？

    **问题处理：**
    *   发现问题 → Vibe Coding → 让 Dev 修复，目标是确保基础功能可用。

    **8.2 UI 还原与调整**

    **前置条件：**
    *   上一步自己测试后没有发现大问题

    **操作方式：**
    *   利用 Figma MCP 进行 UI 调整，可能会改出一些新的问题，我们依旧发现问题 → Vibe Coding → 让 Dev 修复。

    ⚠️ **重要建议：**
    *   不管UI 还原效果如何，只做 1-2 轮 AI 交互，不要在这里浪费时间，主要原因是AI 做不到 100% 还原设计稿。

    **8.3 UI 调整引发问题修复**

    **现象：**
    *   在 UI 调整过程中可能会出现一些新的问题

    **处理方式：**
    *   继续 Vibe Coding，让 Dev 解决这些新问题

    **8.4 QA 完整测试流程**
    ⚠️ **重要：**打开新的会话，控制上下文

    **触发条件：**
    *   人工粗略测试后找不出更多问题

    **执行流程：**
    *   交给 QA 角色执行完整测试流程
    *   进入修复循环：
        *   遇到问题 → Dev 修改
        *   改完后 → QA 测试
        *   重复上述循环，直到 QA 流程完成

    **8.5 多角色联合验收兜底**
    ⚠️ **重要：**打开新的会话，控制上下文

    **前置条件：**
    *   QA 流程已完成

    **准备工作：**
    *   引用所有关键角色：PM、Architect、Dev、QA、PO
    *   再次复制对应 PRD 中的功能模块原始内容作为参考（非常重要）

    **执行方式：**
    *   召开多角色会议（使用 *party-mode 命令或直接说"开会"）
    *   会议议题： 共同验收刚开发完成的整个 Epic 功能

    **验收循环：**
    *   发现问题 → Dev 修改 → QA 验收
    *   重复循环直到所有角色验收通过

    **8.6 代码提交前的最终 Review**

    **前置条件：**
    *   经过上面几轮检查后，功能完整性已基本得到保证

    **执行方式：**
    *   交给架构师进行代码提交前的 Review
    *   这是提交前的最后一轮检查

    **Review 循环：**
    *   发现问题 → Dev 修改 → QA 验收
    *   重复循环直到 Review 通过

### 精细化调优

9.  **人工微调阶段**

    **触发条件：**
    *   按照上述循环方式完成所有 Epic 的开发

    **工作方式：**
    *   切换回 Augment 模式
    *   结合手动调整的方式进行微调

    **主要处理内容：**
    *   小 Bug 修复
    *   交互优化
    *   样式调整
    *   其他细节问题

### 最终交付

10. **交付与验收**

    完成人工微调后：
    *   交付给测试团队进行完整测试
    *   进行 UI 走查
    *   最终交付上线

## 四、关键流程节点速查表

| 步骤 | 阶段 | 是否开新会话 | 主要角色 | 核心产出 | 人工检查重点 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 3 | Epic 拆分 | - | PO | Epic 列表 | - |
| 4 | Stories 拆分 | - | SM | User Stories | - |
| 5 | AI Check | ✅ 新会话 | PM、PO、SM | 修订后的 Epic & Stories | 决策修订意见 |
| 6 | 人工 Check、版本控制 | - | 人工 | 确认版本 | Epic 通读，Stories 看文件名 |
| 7 | 架构设计 | ✅ 新会话 | Architect | 架构文档 | 目录结构、架构模式、技术栈 |
| 8.1 | 功能开发 | ❌ 不开新会话 | Dev | 功能实现 | 功能完整性、明显 Bug |
| 8.2 | UI 调整 | - | Dev + Figma MCP | UI 实现 | 1-2 轮交互即可 |
| 8.4 | QA 测试 | ✅ 新会话 | QA | 测试报告 | - |
| 8.5 | 多角色验收 | ✅ 新会话 | 全员 | 验收通过 | 对照 PRD 原文 |
| 8.6 | Code Review | - | Architect | Review 通过 | - |
| 9 | 人工微调 | - | 人工 + Augment | 最终版本 | 细节完善 |
| 10 | 交付 | - | 测试、UI | 上线 | - |

## 五、核心要点提炼

### 上下文控制策略

**需要打开新会话的场景：**
* AI Check（第 5 步）
* 架构设计（第 7 步）
* QA 测试（第 8.4 步）
* 多角色验收（第 8.5 步）

**不开新会话的场景：**
* 开发阶段（第 8 步）- Dev 需要完整上下文

### 人工检查策略

| 检查对象 | 检查深度 | 原因 |
| :--- | :--- | :--- |
| Epic | 通读全文 | 内容不长，主要是概括性内容 |
| Stories | 仅看文件名 | 避免心智负担，通过文件名判断覆盖范围 |
| 架构文档 | 重点看目录结构、架构模式、技术栈 | 实现时也不会完全遵循，不必过度投入 |

**总原则：** 不必全篇通读所有内容，避免心智负担过大

### AI 使用边界认知

| 场景 | 建议 | 原因 |
| :--- | :--- | :--- |
| Figma UI 还原 | 只做 1-2 轮交互 | AI 做不到 100% 还原 |
| 架构设计 | 不追求完美 | 实现时也不会完全遵循 |
| Epic & Stories 拆分 | 必须经过 AI Check | 存在 AI 幻觉问题 |

### PRD 原文的关键作用

**需要引用 PRD 原文的场景：**
* 第 5 步 AI Check： 让 AI 参考原文修改
* 第 8.5 步多角色验收： 作为验收的权威参考

**作用：** 确保所有环节都以 PRD 为准，避免需求偏移

### 🎯 核心理念

理解 AI 的能力边界，合理分配人工和 AI 的工作，通过流程设计和多轮验证确保功能完整性和最终质量。

通篇来看我们解决的几个重要问题：
* 如何系统设计人机交互工作流
* 如何找到人机交互的平衡点，最常见的问题是 AI 给得太多人就不想看，但不看就会导致质量下降
* 如何做好上下文管理，精准控制上下文

上面这几个问题看起来很难，实则一点都不简单🤓。需要通过长期的 AI 实践经验，在实践中融会贯通并内化为直觉。

所以我个人也认为，AI 时代最重要的能力之一就是找到边界，扩展边界。模型能力在变、模型应用方式在变（Agent、工作流等等），对于个人来说，能不能找到模型的能力边界、能不能找到自己使用模型的能力边界是非常重要的，这是把 AI 用好最重要的能力之一。

## 六、GPT5 给出的评价

对个人而言，这套流程稳定但繁琐，能保证结果一致却牺牲灵活与效率；
对团队而言，它标准化且可复制，能显著提升整体交付质量，但同时增加了培训成本与执行复杂度。

GPT5给出的完整客观评价如下

更完整的和 GPT5 对话的过程如下：（可做参考）

## 七、口述原文备份
完整工作流口述版本备份，上面是经过 AI 优化更易读的竖版内容。

我来讲一下我基于BMAD 如何完成一个需求的：
1. 公司是有产品经理的，我们可以拿到产品经理产出的 prd
2.拿到 prd 导出之后我们到 IDE 中进入 BMAD工作流，告诉元角色 master 我们准备开发一个 xxx 功能
3. PO角色根据 prd中的功能模块划分 拆分为 多个Epic
4. SM 根据prd 和 epic 继续拆分为粒度更小的用户故事

5. [打开新的会话，控制上下文] Epic Stories AI Check 阶段，我们将每个 Epic 对应的 prd 原文直接复制粘贴过来，让 PM、PO、SM 角色同时去 Check Epic 和 Stories，这里大概率会有一些细节问题，并且 AI 会按照严重等级排序说明，我们需要在这里做决策（一般是让他参考 prd 原文修改，也有可能有些缺少的信息我们需要去找 pm 核对）。人工给出修订意见，让 AI去修订第3、4步产出的Epic 和 Stories。这一步有两个考虑，一是 AI 幻觉问题，3、4步产出的结果不一定完全准确；二是大部分人没有足够的耐心看完所有的 Epic 和 Stories；

6. Epic Stories 人工 Check 阶段，人工 Check Epic 和用户故事（需要通读 Epic, Epic一般不会太长，只是一个概括性内容； 并Check 用户故事文件名即可，不需要细读内容）

7. [每次都打开新的会话，控制上下文] 我们用第6步的方法循环检查、修订完所有的 Epic、Stories 后，可以先提交至 git，防止后面 AI 偷改
8. [打开新的会话，控制上下文] 导出API 文档放到项目 docs 中去，把 PRD、Epic、Stories、API 文档同时给到架构师角色，让其做架构设计，写好架构文档。这里人工需要重点 Check 的是目录结构、架构模式、技术栈等内容，不必全篇通读，心智负担会比较大。（即使我们通读全篇修改的非常准确，在实际的实现过程中 AI 也不一定完全遵循，这一点即使人工做架构和实现阶段也是同样的道理，有众多因素影响不可能完全按照架构来实现），所以这里我们不必给太多的精力。
9. [不开新会话，给 Dev 完整上下文]架构文档完成后，我们交给 dev 角色去开发，按照用户故事的顺序依次开发，进入开发循环工作流
9.1 通常是开发完一整个 Epic 后我们去人工 Check，看功能实现是否完整、是否有 Bug，有问题则 Vibe Coding，让 Dev 修复问题，确保基础功能可用。
9.2 自己测不出大问题后，我们利用 Figma MCP 做 UI调整，这里建议不管效果怎么样，我们只做1-2轮 AI 交互，不要浪费时间，因为 AI 做不到100%还原。
9.3 在调整 AI 的过程中可能会出现一些新的问题，我们继续 Vibe Coding 让 Dev 去解决。
9.4 [打开新的会话，控制上下文] 人工粗略测不出更多问题后，我们交给 QA 让其走完整的测试流程。然后依旧是遇到问题 Dev去改，改完 QA 测，直到 QA 流程完成。
9.5 [打开新的会话，控制上下文] QA 流程完成后，我们可以进行多角色验收兜底。我们把 PM、Architect、Dev、QA、PO 全部引用，让他们去开会（可以使用*party-mode 命令，也可以直接说开会），开会的议题是让多角色去共同验收上面开发完的整个 Epic 功能，并且此时我们需要再次把对应 PRD 中的功能模块原始内容复制过来作为参考。然后依旧是发现问题->Dev 修改 -> QA 验收循环
9.5 上面几轮Check 后基本可以保证功能的完整性，此时最后一轮 Check，我们交给架构师做代码提交前的 Review。然后依旧是发现问题->Dev 修改 -> QA 验收循环。
10. 按照上面的循环方式完成所有 Epic 的开发后，就可以进入到人工微调阶段，这个时候我们可以切回 Augment 结合手动调整的方式去微调（主要是一些小 bug、交互、样式等问题）
11. 完成后交付测试、UI走查
